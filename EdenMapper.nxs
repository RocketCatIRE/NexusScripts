{"name":"eden-mapper","enabled":true,"description":"Mapping with AStar","type":"group","id":1,"items":[{"type":"alias","name":"nmap, initiates nmap","enabled":true,"id":5,"matching":"regexp","whole_words":true,"case_sensitive":true,"prefix_suffix":true,"actions":[{"action":"script","script":"ow_Write('#output_main', '<span style=\"color: yellow;\">Beginning construction of Eden Mapper. Standy.</span>')"},{"action":"function","fn":"_map_utils"},{"action":"function","fn":"_map_init"},{"action":"script","script":"map.print('Beginning construction of A* algorithm.')"},{"action":"function","fn":"_nmap_eventify"},{"action":"function","fn":"_nmap_defaults"},{"action":"function","fn":"_nmap_newGraph"},{"action":"function","fn":"_nmap_pfind"},{"action":"script","script":"map.print('AStar algorithms constructed, proceeding to Eden Mapper code.')"},{"action":"function","fn":"_map_interpreted"},{"action":"script","script":"map.print('Eden Mapper construction completed. Perform <i><span class=\"darkred\">-m</span></i> to download map.')"}],"text":"^nmap$"},{"type":"function","name":"onGMCP","enabled":true,"id":30,"code":"// Don't move the position of this function\n\nif (args.gmcp_method === 'Room.Info') {\n  if (typeof mk.gmcp === 'undefined') { mk.gmcp = {} }\n  for (var k in args.gmcp_args) {\n   mk.gmcp[k] = args.gmcp_args[k]\n  }\n  mk.moved()\n}"},{"type":"function","name":"_nmap_eventify","enabled":true,"id":3,"code":"nmap = typeof nmap !== 'undefined' ? nmap : {}\nnmap.eventify = function(obj) {\n  nmap.test(obj)\n  var e    = nmap.makeEventStorage(obj)\n  obj.on   = e.on\n  obj.off  = e.off\n  obj.fire = e.fire\n  return obj }\nnmap.test = function(obj) {\n  if (!obj) { throw new Error('Eventify cannot use falsy object as events subject.') }\n  var reserved = ['on','fire','off']\n  for (var i=0; i<reserved.length; i++) {\n   if (obj.hasOwnProperty(reserved[i])) {\n     throw new Error('Object cannot be eventified, since it already has property \"' + reserved[i] + '\".') }\n  } }\nnmap.makeEventStorage = function(obj) {\n  var r = Object.create(null)\n  return {\n   on: function(en, cb, context) {\n     if (typeof cb !== 'function') { throw new Error('Callback cb is expected to be a function.') }\n     var h = r[en]\n     if (!h) { h = r[en] = [] }\n     h.push({callback: cb, context: context})\n     return obj },\n   off: function(en, cb) {\n     var removal = (typeof en === 'undefined')\n     if (removal) { r = Object.create(null); return obj }\n     if (r[en]) {\n      var d = (typeof cb !== 'function')\n      if (d) { delete r[en] } else {\n        var callbacks = r[en]\n        for (var i=0; i<callbacks.length; i++) { \n         if (callbacks[i].callback === cb) { callbacks.splice(i, 1) }\n        } }\n     }\n     return obj },\n   fire: function(en) {\n     var callbacks = r[en]\n     if (!callbacks) { return obj }\n     var fireArguments\n     if (arguments.length > 1) { fireArguments = Array.prototype.splice.call(arguments,1) }\n     for (var i=0; i<callbacks.length; i++) {\n      var callbackData = callbacks[i]\n      callbackData.callback.apply(callbackData.context, fireArguments) }\n     return obj }\n  }    \n}"},{"type":"function","name":"_nmap_defaults","enabled":true,"id":4,"code":"NO_PATH = []\nif (typeof Object.freeze === 'function') { Object.freeze(NO_PATH) }\n\nnmap = typeof nmap !== 'undefined' ? nmap : {}\nnmap.defaults = {}\nnmap.defaults.heuristic = function() { return 0 }\nnmap.defaults.distance  = function() { return 1 }\nnmap.defaults.compareFScore = function(a, b) { return a.fScore - b.fScore }\nnmap.defaults.setHeapIndex = function(n, h) { n.heapIndex = h }\nnmap.defaults.compareF1Score = function(a, b) { return a.f1 - b.f1 }\nnmap.defaults.compareF2Score = function(a, b) { return a.f2 - b.f2 }\nnmap.defaults.setH1 = function(n, h) { n.h1 = h }\nnmap.defaults.setH2 = function(n, h) { n.h2 = h }\n\nnmap.searchState = function() {\n var currentInCache = 0\n var nodeCache      = []\n var reset = function() { currentInCache = 0 }\n var createNewState = function(node) {\n   var cached = nodeCache[currentInCache]\n   if (cached) {\n    cached.node = node\n    cached.parent = null\n    cached.closed = false\n    cached.open   = 0\n    cached.distanceToSource = Number.POSITIVE_INFINITY\n    cached.fScore = Number.POSITIVE_INFINITY\n    cached.heapIndex = -1\n   } else {\n    cached = new NodeSearchState(node)\n    nodeCache[currentInCache] = cached }\n   currentInCache++\n   return cached }\n return {\n   createNewState: createNewState,\n   reset         : reset\n } }\n\nNodeHeap = function(data, options) {\n if (!(this instanceof NodeHeap)) { return new NodeHeap(data, options) }\n if (!Array.isArray(data)) {\n   options = data\n   data    = [] }\n var options   = options || {}\n this.data     = data    || []\n this.length    = this.data.length\n this.compare   = options.compare   || function(a,b){ return a-b }\n this.setNodeId = options.setNodeId || function(){}\n if (this.length > 0) {\n   for (var i=(this.length >> 1); i>=0; i--) {\n    this._down(i) } }\n if (options.setNodeId) {\n   for (var i=0; i<this.length; ++i) {\n    this.setNodeId(this.data[i], i) } }\n}\n\nNodeHeap.prototype = {\n push: function(item) {\n   this.data.push(item)\n   this.setNodeId(item, this.length)\n   this.length++\n   this._up(this.length - 1) },\n pop : function() {\n   if (this.length === 0) { return undefined }\n   var top = this.data[0]\n   this.length--\n   if (this.length > 0) {\n    this.data[0] = this.data[this.length]\n    this.setNodeId(this.data[0], 0)\n    this._down(0) }\n   this.data.pop()\n   return top },\n peek: function() { return this.data[0] },\n updateItem: function(pos) {\n   this._down(pos)\n   this._up(pos) },\n _up: function(pos) {\n   var data      = this.data\n   var compare   = this.compare\n   var setNodeId = this.setNodeId\n   var item      = data[pos]\n   while (pos > 0) {\n    var parent  = (pos - 1) >> 1\n    var current = data[parent]\n    if (compare(item, current) >= 0) { break }\n    data[pos]   = current\n    setNodeId(current, pos)\n    pos         = parent }\n   data[pos] = item\n   setNodeId(item, pos) },\n _down: function(pos) {\n   var data       = this.data\n   var compare    = this.compare\n   var halfLength = this.length >> 1\n   var item       = data[pos]\n   var setNodeId  = this.setNodeId\n   while (pos < halfLength) {\n    var left  = (pos << 1) + 1\n    var right = left + 1\n    var best  = data[left]\n    if (right < this.length && compare(data[right], best) < 0 ) {\n     left = right\n     best = data[right] }\n    if (compare(best, item) >= 0) { break }\n    data[pos] = best\n    setNodeId(best, pos)\n    pos       = left }\n   data[pos] = item\n   setNodeId(item, pos) }\n}\n\n// Heuristics\nl2 = function(a, b) {\n var dx = a.x - b.x\n var dy = a.y - b.y\n return Math.sqrt( dx * dx + dy * dy ) }\n \nl1 = function(a, b) {\n var dx = a.x - b.x\n var dy = a.y - b.y\n return Math.abs(dx) + Math.abs(dy) }\n \n// State Machine\nNodeSearchState = function(node) {\n this.node   = node\n this.parent = null\n this.closed = false\n this.open   = 0\n this.distanceToSource = Number.POSITIVE_INFINITY\n this.fScore = Number.POSITIVE_INFINITY\n this.heapIndex = -1 }"},{"type":"function","name":"_nmap_newGraph","enabled":true,"id":6,"code":"nmap = typeof nmap !== 'undefined' ? nmap : {}\n\nnmap.newGraph = function(options) {\n var options = options || {}\n if (options.multigraph === undefined) { options.multigraph = false }\n var nodes = typeof Object.create === 'function' ? Object.create(null) : {}\n var links = []\n var multiEdges = {}\n var nodesCount = 0\n var suspendEvents = 0\n \n var forEachNode = function(cb) {\n  if (typeof cb !== 'function') { return }\n  if (Object.keys) {\n    var keys = Object.keys(nodes)\n    for (var i=0; i<keys.length; i++) {\n     if (cb(nodes[keys[i]])) { return true } }\n  } else {\n    for (var node in nodes) {\n     if (cb(nodes[node])) { return true } }\n  } }\n\n var makeLinkId = function(a, b) { return a.toString() + ' > ' + b.toString() }\n var Link       = function(a, b, data, id) {\n   this.fromId  = a\n   this.toId    = b\n   this.data    = data\n   this.id      = id }\n var getLink    = function(a, b) {\n   var node = getNode(a)\n   var i\n   if (!node || !node.links) { return null }\n   for (var i=0; i<node.links.length; i++) {\n    var link = node.links[i]\n    if (link.fromId === a && link.toId === b) { return link }\n   }\n   return null }\n\n var createLink = function(fromId, toId, data) {\n  var m = makeLinkId(fromId, toId)\n  if (options.multigraph) {\n    var x = multiEdges.hasOwnProperty(m)\n    if (x || getLink(fromId, toId)) {\n     if (!x) { multiEdges[m] = 0 }\n     var suffix = '@' + (++multiEdges[m])\n     m = makeLinkId(fromId + suffix, toId + suffix)\n    }\n    return new Link(fromId, toId, data, m)\n  } else { // single link\n    return new Link(fromId, toId, data, m)\n  }\n }\n\n var holder = function() {}\n var changes = []\n var recordLinkChange  = holder\n var recordNodeChange  = holder\n var enterModification = holder\n var exitModification  = holder\n\n var Node     = function(id, data) {\n   this.id    = id\n   this.links = null\n   this.data  = data }\n var getNode = function(id) { return nodes[id] }\n var addLinkToNode = function(node, link) {\n   if (node.links) {\n    node.links.push(link)\n   } else {\n    node.links = [link]\n   } }\n var getLinks   = function(id) {\n   var node = getNode(id)\n   return node ? node.links : null }\n\n var addNode = function(id, data) {\n  if (id === undefined) { throw new Error('Invalid node identifier.') }\n  enterModification()\n  var node = getNode(id)\n  if (!node) {\n    node = new Node(id, data)\n    nodesCount++\n    recordNodeChange(node, 'add')\n  } else {\n    node.data = data\n    recordNodeChange(node, 'update') }\n  nodes[id] = node\n  exitModification()\n  return node }\n\n var addLink = function(a, b, data) {\n  enterModification()\n  var fromNode = getNode(a) || addNode(a)\n  var toNode   = getNode(b) || addNode(b)\n  var link     = createLink(a, b, data)\n  links.push(link)\n  addLinkToNode(fromNode, link)\n  if (a !== b) { addLinkToNode(toNode, link) }\n  recordLinkChange(link, 'add')\n  exitModification()\n  return link }\n \n var removeLink = function(link) {\n  if (!link) { return false }\n  var idx = links.indexOf(link)\n  if (idx < 0) { return false }\n  enterModification()\n  links.splice(idx, 1)\n  var a = getNode(link.fromId)\n  var b = getNode(link.toId)\n  if (a) {\n    idx = a.links.indexOf(link)\n    if (idx >= 0) { a.links.splice(idx, 1) }\n  }\n  if (b) {\n    idx = b.links.indexOf(link)\n    if (idx >= 0) { b.links.splice(idx, 1) }\n  }\n  recordLinkChange(link, 'remove')\n  exitModification()\n  return true }\n\n var removeNode = function(id) {\n  var node = getNode(id)\n  if (!node) { return false }\n  enterModification()\n  var prevLinks = node.links\n  if (prevLinks) {\n    node.links = null\n    for (var i=0; i<prevLinks.length; i++) { removeLink(prevLinks[i]) }\n  }\n  delete nodes[id]\n  nodesCount--\n  recordNodeChange(node, 'remove')\n  exitModification()\n  return true }\n\n var forEachOrientedLink = function(links, id, cb) {\n   var qf\n   for (var i=0; i<links.length; i++) {\n    var link = links[i]\n    if (link.fromId === id) {\n      qf = cb(nodes[link.toId], link)\n      if (qf) { return true }\n    }\n   } }\n var forEachNonOrientedLink = function(links, id, cb) {\n   var qf\n   for (var i=0; i<links.length; i++) {\n    var link = links[i]\n    var linkedId = link.fromId === id ? link.toId : link.fromId\n    qf = cb(nodes[linkedId], link)\n    if (qf) { return true }\n   } }\n var forEachLinkedNode = function(id, cb, oriented) {\n   var n = getNode(id)\n   if (n && n.links && typeof cb === 'function') {\n    if (oriented) {\n      return forEachOrientedLink(n.links, id, cb)\n    } else {\n      return forEachNonOrientedLink(n.links, id, cb)\n    }\n   } }\n\n var forEachLink = function(cb) {\n   var i, length\n   if (typeof cb === 'function') {\n    for (i=0, length=links.length; i < length; i++) { cb(links[i]) }\n   } }\n\n var clear = function() {\n   enterModification()\n   forEachNode(function(node) { removeNode(node.id) })\n   exitModification() }\n\n var g = {\n   addNode      : addNode,\n   addLink      : addLink,\n   removeLink   : removeLink,\n   removeNode   : removeNode,\n   getNode      : getNode,\n   getNodesCount: function () { return nodesCount },\n   getLinksCount: function () { return links.length },\n   getLinks     : getLinks,\n   forEachNode  : forEachNode,\n   forEachLinkedNode: forEachLinkedNode,\n   forEachLink  : forEachLink,\n   beginUpdate  : enterModification,\n   endUpdate    : exitModification,\n   clear        : clear,\n   hasLink      : getLink,\n   hasNode      : getNode,\n   getLink      : getLink\n }\n nmap.eventify(g)\n\n var recordLinkChangeReal = function(link, changeType) {\n   changes.push({\n    link: link,\n    changeType: changeType })\n }\n var recordNodeChangeReal = function(node, changeType) {\n   changes.push({\n    node: node,\n    changeType: changeType })\n }\n var enterModificationReal = function() { suspendEvents += 1 }\n var exitModificationReal  = function() {\n   suspendEvents -= 1\n   if (suspendEvents === 0 && changes.length > 0) {\n    g.fire('changed', changes)\n    changes.length = 0\n   } }\n var monitoring = function() {\n   var realOn = g.on\n   var on = function() {\n    g.beginUpdate = enterModification = enterModificationReal\n    g.endUpdate   = exitModification  = exitModificationReal\n    recordLinkChange = recordLinkChangeReal\n    recordNodeChange = recordNodeChangeReal\n    g.on = realOn\n    return realOn.apply(g, arguments) }\n   g.on = on }\n\n monitoring()\n return g }"},{"type":"function","name":"_nmap_pfind","enabled":true,"id":7,"code":"/*\n  Requires nmap.searchState\n */\n\nnmap = typeof nmap !== 'undefined' ? nmap : {}\n   \nnmap.pfind = function(graph, options) {\n var options   = options || {}\n var defaults  = nmap.defaults\n var oriented  = options.oriented\n var heuristic = options.heuristic\n var distance  = options.distance\n if (!heuristic) { heuristic = defaults.heuristic }\n if (!distance)  { distance = defaults.distance }\n var pool = nmap.searchState()\n\n var goalReached = function(state, node) { return state.node === node }\n var buildPath   = function(state) {\n   var path   = [state.node]\n   var parent = state.parent\n   while (parent) { path.push(parent.node); parent = parent.parent }\n   return path }\n\n var find = function(a, b) {\n   var from = graph.getNode(a)\n   var to   = graph.getNode(b)\n   if (!from) { throw new Error('fromID is not defined in this graph: ' + a + '.') }\n   if (!to)   { throw new Error('toID is not defined in this graph: ' + b + '.') }\n   pool.reset()\n\n   // var nodeState = new Map() // native Javascript\n   var nodeState = {}\n   var openSet = new NodeHeap({\n    compare  : defaults.compareFScore,\n    setNodeId: defaults.setHeapIndex,\n   })\n   var startNode = pool.createNewState(from)\n   // nodeState.set(a, startNode)\n   nodeState[a] = startNode\n   startNode.fScore = heuristic(from, to)\n   startNode.distanceToSource = 0\n   openSet.push(startNode)\n   startNode.open = 1\n\n   var cameFrom\n   var visitation = function(otherNode, link) {\n    // var otherSearchState = nodeState.get(otherNode.id)\n    var otherSearchState = nodeState[otherNode.id]\n    // if (!otherSearchState) { otherSearchState = pool.createNewState(otherNode); nodeState.set(otherNode.id, otherSearchState) }\n    if (!otherSearchState) { otherSearchState = pool.createNewState(otherNode); nodeState[otherNode.id] = otherSearchState }\n    if (otherSearchState.closed) { return }\n    if (otherSearchState.open === 0) { openSet.push(otherSearchState); otherSearchState.open = 1 }\n    var tentativeDistance = cameFrom.distanceToSource + distance(otherNode, cameFrom.node, link)\n    if (tentativeDistance >= otherSearchState.distanceToSource) { return } // longer!\n    otherSearchState.parent = cameFrom\n    otherSearchState.distanceToSource = tentativeDistance\n    otherSearchState.fScore = tentativeDistance + heuristic(otherSearchState.node, to)\n    openSet.updateItem(otherSearchState.heapIndex)\n   }\n\n   while (openSet.length > 0) {\n    cameFrom = openSet.pop()\n    if (goalReached(cameFrom, to)) { return buildPath(cameFrom) }\n    cameFrom.closed = true\n    graph.forEachLinkedNode(cameFrom.node.id, visitation, oriented)\n   }\n\n   return NO_PATH\n }\n\n return { find: find }\n}"},{"type":"function","name":"_map_utils","enabled":true,"id":8,"code":" map = typeof map !== 'undefined' ? map : {}\n\n // Printing\n map.classname = 'eden-mapper'\n map.inject = function(rule) { $('body').append('<div class=\"' + map.classname + '\">&shy;<style>' + rule + '</style></div>') }\n if ($('.'+map.classname).length) { $('.'+map.classname).remove() }\n map.inject('.turquoise { color: rgba(  80, 135, 145, 1); }')\n map.inject('.darkred   { color: rgba( 185,  15,  65, 1); }')\n map.inject('.green     { color: rgba(  15, 115,  75, 1); }')\n map.inject('.normal    { color: rgba( 185, 185, 185, 1); }')\n\n map.print = function(msg) {\n   var msg = '<span class=\"turquoise\">[<span class=\"darkred\">map</span>] ' + msg + '</span>'\n   ow_Write('#output_main', msg) }\n\n // source: https://davidwalsh.name/convert-xml-json\n map.xtjs = function(xml) {\n   var obj = {}\n   if (xml.nodeType == 1) {\n    if (xml.attributes.length > 0) {\n      obj[\"@attributes\"] = {}\n      for (var j=0; j<xml.attributes.length; j++) {\n       var attr = xml.attributes.item(j)\n       obj[\"@attributes\"][attr.nodeName] = attr.nodeValue }\n    }\n   } else if (xml.nodeType == 3) {\n    obj = xml.nodeValue }\n   if (xml.hasChildNodes()) {\n    for (var i=0; i<xml.childNodes.length; i++) {\n      var item = xml.childNodes.item(i)\n      var nodeName = item.nodeName\n      if (typeof obj[nodeName] == 'undefined') {\n       obj[nodeName] = map.xtjs(item)\n      } else {\n       if (typeof obj[nodeName].push == 'undefined') {\n         var old = obj[nodeName]\n         obj[nodeName] = []\n         obj[nodeName].push(old)\n       }\n       obj[nodeName].push(map.xtjs(item))\n     }\n   }\n  }\n  return obj }\n \n map.clone = function(obj) {\n   var copy\n   if (null == obj || 'object' != typeof obj) { return obj }\n   if (obj instanceof Date) { \n    copy = new Date()\n    copy.setTime(obj.getTime())\n    return copy }\n   if (obj instanceof Array) {\n    copy = []\n    for (var i=0; i<obj.length; i++) {\n      copy[i] = map.clone(obj[i]) }\n    return copy }\n   if (obj instanceof Object) {\n    copy = {}\n    for (var attr in obj) {\n      if (obj.hasOwnProperty(attr)) {\n       copy[attr] = map.clone(obj[attr]) } }\n    return copy }\n   throw new Error('Unable to copy obj! Type not supported.') }\n \n map.lpad = function(str, len, ch) {\n   if (typeof str == 'number') { str = str.toString() }\n   if (ch == null) { ch = ' ' }\n   var r = len - str.length\n   if (r < 0) { r = 0 }\n   return ch.repeat(r) + str }\n \n map.title = function(str) {\n   return str.replace(/\\w\\S*/g, function(txt){return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();}) }\n \n map.rpad = function(str, len, ch) {\n   if (typeof str == 'number') { str = str.toString() }\n   if (ch == null) { ch = ' ' }\n   var r = len - str.length\n   if (r < 0) { r = 0 }\n   return str + ch.repeat(r) }"},{"type":"function","name":"_map_init","enabled":true,"id":9,"code":"/*\n This module uses https://cors-anywhere.herokuapp.com/\n This may represent a failure point should the module stop working.\n The url bypasses the Achaean server's non-use of cross-origin resource requests. Replication of the herokuapp behaviour may need to be reinstated if there are concerns about this third party functionality.\n */\n\n map = typeof map !== 'undefined' ? map : {}\n\n map.url       = 'https://www.achaea.com/maps/map.xml'\n map.cors      = 'https://cors-anywhere.herokuapp.com/'\n\n map.grab = function() {\n   var url = map.cors + map.url\n   map.print('Downloading map from ' + url + '.')\n   /* var x = $.ajax({ url: url, type: 'HEAD', success: function(e) { log(x) }, }) */\n   $.ajax({\n    url: url,\n    type: 'GET',\n   }).done( function(e) {\n    map.age = new Date().getTime() // tracking\n    map.raw = e\n    map.m = map.xtjs(e)\n    map.print('Map download from <span class=\"darkred\">' + url + '</span> complete.')\n    map.convert()\n    if (typeof mk !== 'undefined' && typeof mk.fashion == 'function') { mk.fashion() }\n    map.print(' Processing time: <span class=\"darkred\">' + (new Date().getTime() - map.age) + '</span>ms.<br >')\n   }).fail( function() { map.print('Error downloading ' + url + '.'); console.log('Error downloading ' + url + '.') })\n }\n\n map.convert = function() {\n   var t = map.clone(map.m)\n       t = t.map\n   var u\n   var out = {}\n       out.areas = {}\n       out.envs  = {}\n       out.rooms = {}\n   var b = 0\n   var g = 0\n   var h = 0\n   // areas\n   u = t || {}; u = u.areas || {}; u = u.area || []; b = u.length;\n   for (var i=0; i<u.length; i++) {\n    var n = u[i][\"@attributes\"]\n    out.areas[n.id] = n.name\n   }\n   // environments\n   u = t || {}; u = u.environments || {}; u = u.environment || []; g = u.length;\n   for (var i=0; i<u.length; i++) {\n    var n = u[i][\"@attributes\"]\n    out.envs[n.id] = {name: n.name, color: n.color, hcolor: n.htmlcolor}\n   }\n   // rooms\n   u = t || {}; u = u.rooms || {}; u = u.room || []; h = u.length;\n   for (var i=0; i<u.length; i++) {\n    var n = u[i]\n    var a = n[\"@attributes\"]\n    var c = n[\"coord\"][\"@attributes\"]\n    var e = n[\"exit\"]\n    var o = {}\n        o = map.clone(a)\n        o.x = c.x\n        o.y = c.y\n        o.z = c.z\n    o.exits = {}\n    if (typeof e !== 'undefined' && e.length > 0) {\n      for (var j=0; j<e.length; j++) {\n       var k = e[j][\"@attributes\"]\n       o.exits[k.direction] = parseInt(k.target)\n      } }\n    o.id = parseInt(o.id)\n    out.rooms[o.id] = o\n   }\n   map.m = out\n   if (map.m.rooms && map.m.rooms[12695]) { map.m.rooms[12695].exits = {down: 12632} } // don't know why this won't interpret\n   map.print(' Processed <span class=\"darkred\">' + g + '</span> environments, <span class=\"darkred\">' + b + '</span> areas and <span class=\"darkred\">' + h + '</span> rooms.')\n }\n \n // API\n map.find = function(phrase, area) {\n  var p    = new Date().getTime()\n  var searchTerm = new RegExp(phrase, 'gi')\n  var r    = map.m.rooms\n  var a    = map.m.areas\n  var c    = 0\n  var s    = 'Searching for <span class=\"normal\"><i>' + phrase + '</i></span>:<br >'\n  var keys = Object.keys(r)\n  var out  = {}\n  var areas = []\n  for (var i=0; i<keys.length; i++) {\n    var n  = r[keys[i]]\n    var t  = n.title\n    var ar = a[n.area] || 'Unknown'\n    if (t.match(searchTerm)) {\n     c += 1\n     if (!out[ar]) { out[ar] = [] }\n     if (areas.indexOf(ar) == -1) { areas.push(ar) }\n     out[ar].push({id: n.id, title: t})\n    }\n  }\n  areas.sort()\n  // https://stackoverflow.com/a/2466503\n  var byProperty = function(prop) { return function(a, b) {\n    if (typeof a[prop] == 'number') { return (a[prop] - b[prop]) } else { return ((a[prop] < b[prop]) ? -1 : ((a[prop] > b[prop]) ? 1 : 0)) }\n  } }\n  for (var i=0; i<areas.length; i++) {\n    var k = areas[i]\n    var o = []\n    if (typeof out[k] == 'undefined') {} else {\n    out[k].sort(byProperty('title'))\n    for (var j=0; j<out[k].length; j++) {\n     var n = out[k][j]\n     s += ' [ <span class=\"darkred\">' + map.lpad(n.id,5,' ') + '</span> ] <span class=\"normal\">' + n.title + '</span> <span class=\"mute\"><i>' + '.'.repeat((53 - n.title.length)) + k + '</i></span><br >'\n    } }\n  }\n  s += 'Search time: ' + (new Date().getTime() - p) + ' ms finding ' + c + ' hits in ' + keys.length + ' rooms.<br >'\n  if (c > 50) {\n   s += 'Recommend refining search term: <span class=\"normal\"><i>' + phrase + '</span></i>.' \n  }\n  map.print(s)\n }\n\n map.areafind = function(phrase) {\n  var p    = new Date().getTime()\n  var searchTerm = new RegExp(phrase, 'gi')\n  var a    = map.m.areas\n  var c    = 0\n  var t    = 0\n  var s    = 'Searching for <span class=\"normal\"><i>' + phrase + '</i></span>: <br >'\n  for (var k in a) {\n    t += 1\n    if (a[k].match(searchTerm)) {\n     c += 1\n     s += ' [ <span class=\"green\">' + map.lpad(k,4,' ') + '</span> ] ' + a[k] + '<br >'\n    }\n  }\n  s += 'Search time: ' + (new Date().getTime() - p) + ' ms finding ' + c + ' in ' + t + ' areas.<br >'\n  map.print(s)\n }"},{"type":"function","name":"_map_interpreted","enabled":true,"id":14,"code":"/*\n  When WebWorkers are allowed to pass functions, this should be updated.\n */\n\n mk = typeof mk !== 'undefined' ? mk : {}\n mk.lpad   = map.lpad\n mk.rpad   = map.rpad\n mk.print  = map.print\n mk.send   = send_direct\n\n mk.here   = mk.here || 0\n mk.area   = mk.area || 0\n mk.waters = ['10', '20', '22', '24', '25', '30', '34']\n mk.moving      = mk.moving      || false\n mk.garmin      = mk.garmin      || []    // pathfinder holding! Lel\n mk.destination = mk.destination || ''    // hrm\n mk.useDuanathar  = mk.useDuanathar || false\n mk.useVeil       = mk.useVeil      || false\n mk.separatorWalk = true\n mk.separator     = '|'\n mk.moveLimit     = 3\n mk.spamLimit     = 12\n mk.velocity      = 630                   // speed to send movement commands\n mk.velocityMulti = 370 * mk.moveLimit\n mk.swimspeed     = 1080\n mk.spamCount     = 0\n mk.debug         = false\n mk.mode          = 'n'\n mk.forceDuanathar  = false\n mk.forceVeil       = false\n mk.veilspeed       = 2700  // ms\n mk.duanatharOrigin = 3885\n mk.duanatharMethod = ['g wings from pack','wear wings','say duanathar','remove wings','put wings in pack']\n mk.veilOrigin      = 12695\n mk.veilMethod      = ['pierce the veil']\n mk.preferDV        = 'veil'\n\n mk.reports = function(str) { if (mk.debug) { log(str) } }\n mk.isWater = function(roomID) {\n   var r = map.m.rooms\n   var g = r[roomID]\n   if (typeof g === 'undefined') { return false } else {\n    if (mk.waters.indexOf(g.environment) != -1) { return true }\n   }\n   return false }\n \n mk.assign = function() {\n   switch (mk.mode) {\n    case ('w'):\n    case ('n'):\n    default:\n      mk.map  = mk.mapn\n      mk.fmap = mk.fmapn\n      break;\n   }\n }\n \n // Passed Function, no access to general variables!\n mk.fashion = function() {\n   var p = new Date().getTime()\n   var waters = mk.waters\n\n   mk.mapn   = nmap.newGraph() // vanilla\n   mk.mapd   = nmap.newGraph() // duanathar\n   mk.mapw   = nmap.newGraph() // waterwalker\n   mk.mapW   = nmap.newGraph() // no water!\n   mk.mapv   = nmap.newGraph() // veil\n   mk.mapdv  = nmap.newGraph() // duanathar + veil\n   mk.mapdw  = nmap.newGraph() // duanathar + waterwalker\n   mk.mapvw  = nmap.newGraph() // veil + waterwalker\n   mk.mapdvw = nmap.newGraph() // duanathar + veil + waterwalker\n\n   var m    = map.m.rooms\n   var keys = Object.keys(m)\n   for (var i=0; i<keys.length; i++) {\n    var r = m[keys[i]]\n    mk.mapn.addNode(parseInt(keys[i]), {title: r.title, env: r.environment, area: r.area})\n    mk.mapd.addNode(parseInt(keys[i]), {title: r.title, env: r.environment, area: r.area})\n    mk.mapw.addNode(parseInt(keys[i]), {title: r.title, env: r.environment, area: r.area})\n    mk.mapW.addNode(parseInt(keys[i]), {title: r.title, env: r.environment, area: r.area})\n    mk.mapv.addNode(parseInt(keys[i]), {title: r.title, env: r.environment, area: r.area})\n    mk.mapdv.addNode(parseInt(keys[i]), {title: r.title, env: r.environment, area: r.area})\n    mk.mapdw.addNode(parseInt(keys[i]), {title: r.title, env: r.environment, area: r.area})\n    mk.mapvw.addNode(parseInt(keys[i]), {title: r.title, env: r.environment, area: r.area})\n    mk.mapdvw.addNode(parseInt(keys[i]), {title: r.title, env: r.environment, area: r.area})\n    if (r.area == '190') { // veil\n      var k = Object.keys(r.exits)\n      for (var j=0; j<k.length; j++) {\n       mk.mapv.addLink(parseInt(keys[i]), r.exits[k[j]], {weight: 1})\n       mk.mapdv.addLink(parseInt(keys[i]), r.exits[k[j]], {weight: 1})\n       mk.mapvw.addLink(parseInt(keys[i]), r.exits[k[j]], {weight: 1})\n       mk.mapdvw.addLink(parseInt(keys[i]), r.exits[k[j]], {weight: 1})\n      }\n    } else if (r.id == 3885) { // duanathar\n      var k = Object.keys(r.exits)\n      for (var j=0; j<k.length; j++) {\n       mk.mapd.addLink(parseInt(keys[i]), r.exits[k[j]], {weight: 1})\n       mk.mapdv.addLink(parseInt(keys[i]), r.exits[k[j]], {weight: 1})\n       mk.mapdw.addLink(parseInt(keys[i]), r.exits[k[j]], {weight: 1})\n       mk.mapdvw.addLink(parseInt(keys[i]), r.exits[k[j]], {weight: 1})\n      }\n    } else {\n      var weight = 1\n      if (mk.isWater(parseInt(keys[i]))) { weight = 2.3 }\n      var k = Object.keys(r.exits)\n      for (var j=0; j<k.length; j++) {\n       var t  = parseInt(r.exits[k[j]])\n       var nw = weight\n       if (mk.isWater(t)) { nw = 2.3 }\n       mk.mapn.addLink(parseInt(keys[i]), t,  {weight: nw})\n       mk.mapd.addLink(parseInt(keys[i]), t, {weight: nw})\n       mk.mapw.addLink(parseInt(keys[i]), t, {weight: 1})\n       mk.mapW.addLink(parseInt(keys[i]), t, {weight: 1})\n       mk.mapv.addLink(parseInt(keys[i]), t, {weight: nw})\n       mk.mapdv.addLink(parseInt(keys[i]), t, {weight: nw})\n       mk.mapdw.addLink(parseInt(keys[i]), t, {weight: 1})\n       mk.mapvw.addLink(parseInt(keys[i]), t, {weight: 1})\n       mk.mapdvw.addLink(parseInt(keys[i]), t, {weight: 1})\n      }\n    }\n   }\n   mk.fmapn = nmap.pfind(mk.mapn, {oriented: true})\n   mk.fmapw = nmap.pfind(mk.mapw, {oriented: true})\n   mk.fmapv = nmap.pfind(mk.mapv, {oriented: true})\n   mk.fmapd = nmap.pfind(mk.mapd, {oriented: true})\n   mk.fmapdv  = nmap.pfind(mk.mapdv,  {oriented: true})\n   mk.fmapdw  = nmap.pfind(mk.mapdw,  {oriented: true})\n   mk.fmapvw  = nmap.pfind(mk.mapvw,  {oriented: true})\n   mk.fmapdvw = nmap.pfind(mk.mapdvw, {oriented: true})\n\n   mk.assign()\n   mk.print('Created pathfinders. <span class=\"mute\">Performance: ' + (new Date().getTime() - p) + ' ms.</span>')\n }\n\n mk.stop = function() {\n   mk.print('Stopping <span class=\"darkyellow\">mk walker</span>.<br >')\n   // mk.scroll()\n   mk.moving = false\n   clearTimeout(mk.timer) }\n mk.walk = function() {\n   if (!mk.moving) { clearTimeout(mk.timer); return }\n   var t = mk.garmin\n   var v = mk.velocity\n   if (t.length > 0) {\n    var s = ''\n    if (mk.separatorWalk) {\n      v = mk.velocityMulti\n      for (var i=0; i<(Math.min(mk.moveLimit,mk.garmin.length)); i++) {\n       s += t[i].dir + mk.separator\n       if (t[i].dir.match('swim ')) { v = mk.swimspeed; break }\n       if (t[i].dir.match('pierce the veil')) { v = mk.veilspeed; break }\n      }\n    } else {\n     s += t[0].dir\n     if (t[0].dir.match('swim ')) { v = mk.swimspeed }\n     if (t[0].dir.match('pierce the veil ')) { v = mk.veilspeed }\n    }\n   }\n   mk.send(s)\n   mk.moving = true\n   mk.print('Moving in direction <i>' + s + '</i>. <span class=\"red\"><b>mstop</b></span> to stop.')\n   // mk.scroll()\n   mk.timer = setTimeout(mk.walk, v)\n }\n mk.goto = function(to) {\n   mk.reports('Heading to ' + to + ' from ' + mk.here)\n   mk.spamCount = 0\n   clearTimeout(mk.timer)\n   var r = map.m.rooms\n   var out    = []\n   var g = mk.fmap.find(mk.here, parseInt(to))\n   /*\n     Calculate and compare duanathar/veil here\n    */\n   if (g.length == 1 && g[(g.length - 1)].id == mk.here) {\n     mk.print('Looks like you\\'re already there.')\n   } else if (g.length > 0) {\n     for (var j=(g.length - 1); j>-1; --j) {\n       var e = r[g[j].id].exits\n       for (var k in e) {\n        if (j > 0 && e[k] == parseInt(g[(j - 1)].id)) {\n          var dir = k\n          if (mk.isWater(g[j].id)) { dir = 'swim ' + dir } else if (mk.isWater(e[k])) { dir = 'swim ' + dir }\n          out.push({dir: dir, target: e[k]})\n          break\n        }\n       }\n     }\n     mk.print('Attempting to navigate to #<span class=\"darkred\">' + to + '</span> in ' + g.length + ' steps.')\n     mk.garmin      = out\n     mk.destination = to\n     mk.moving      = true\n     mk.reports(mk.garmin)\n     mk.timer = setTimeout(mk.walk, mk.velocity)\n   } else {\n     mk.print('Path length of 0 steps to #<span class=\"darkred\">' + to + '</span>. There may be no valid path.')\n   }\n }\n mk.goNext = function(to) {\n   mk.reports('Heading to ' + to + ' from ' + mk.here)\n   mk.spamCount = 0\n   clearTimeout(mk.timer)\n   var r = map.m.rooms\n   var out    = []\n   var g = mk.fmap.find(mk.here, parseInt(to))\n\n   /*\n    * Calculate Special Movement\n    */\n   var duanathar = false\n   var veil      = false\n   // Duanathar\n   var h = mk.fmapd.find(mk.duanatharOrigin, parseInt(to))\n   if (h.length >= g.length && g.length != 0 && !mk.forceDuanathar) {\n     /* use regular */\n   } else if (mk.indoors()) {\n     /* don't fly   */\n   } else if ((g.length - h.length) > 4) {\n     duanathar = true\n   }\n   // Veil\n   var f = mk.fmapv.find(mk.veilOrigin, parseInt(to))\n   if (f.length >= g.length && g.length != 0 && !mk.forceVeil) {\n     /* use regular */\n   } else if (!mk.isDragon()) {\n     /* not dragon  */\n   } else if (mk.separatorWalk && ((mk.velocityMulti * (g.length - f.length) / mk.moveLimit) > (mk.veilspeed / 1000))) {\n     /* slower than multiwalk */\n     veil = true\n   } else if (!mk.separatorWalk && (((g.length - f.length) * mk.velocity / 1000) > (mk.veilspeed / 1000) )) {\n     /* slower than single walk */\n     veil = true\n   }\n   if (mk.useDuanathar && mk.preferDV == 'duanathar' && duanathar) {\n     out.push({dir: mk.duanatharMethod.join(mk.separator), target: mk.duanatharOrigin})\n     g = h\n   } else if (mk.useVeil && mk.preferDV == 'veil' && veil) {\n     out.push({dir: mk.veilMethod.join(mk.separator), target: mk.veilOrigin})\n     g = f\n   } else if (mk.useDuanathar && duanathar) {\n     out.push({dir: mk.duanatharMethod.join(mk.separator), target: mk.duanatharOrigin})\n     g = h\n   } else if (mk.useVeil && veil) {\n     out.push({dir: mk.veilMethod.join(mk.separator), target: mk.veilOrigin})\n     g = f\n   } else {\n     if (g.length == 0 && f.length > 0) {\n      mk.print('Going to use Veil pathing as normal pathing was invalid.')\n      g = f\n     }\n   }\n   /*\n    * End Special Movement\n    */\n   if (g.length > 0) { g.shift() }  // This line grants 'adjacent'\n   if (g.length == 1 && g[(g.length - 1)].id == mk.here) {\n     mk.print('Looks like you\\'re already there.')\n   } else if (g.length > 0) {\n     for (var j=(g.length - 1); j>-1; --j) {\n       var e = r[g[j].id].exits\n       for (var k in e) {\n        if (j > 0 && e[k] == parseInt(g[(j - 1)].id)) {\n          var dir = k\n          if (mk.isWater(g[j].id)) { dir = 'swim ' + dir } else if (mk.isWater(e[k])) { dir = 'swim ' + dir }\n          out.push({dir: dir, target: e[k]})\n          break\n        }\n       }\n     }\n     mk.print('Attempting to navigate adjacent to #<span class=\"darkred\">' + to + '</span> in ' + g.length + ' steps.')\n     mk.garmin      = out\n     mk.destination = g[0].id\n     mk.moving      = true\n     mk.reports(mk.garmin)\n     mk.timer = setTimeout(mk.walk, mk.velocity)\n   } else {\n     mk.print('Path length of 0 steps to #<span class=\"darkred\">' + to + '</span>. There may be no valid path.')\n   }\n }\n mk.spam = function() {\n   mk.spamCount += 1\n   if (mk.spamCount > mk.spamLimit) {\n    mk.print('Hitting spam limit of ' + mk.spamLimit + '.')\n    mk.stop()\n   } }\n mk.moved = function() {\n   var here = parseInt(mk.gmcp.num)\n   if (!mk.here) {\n    mk.here = parseInt(mk.gmcp.num) }\n \n   if (mk.moving && \n       typeof mk.garmin !== 'undefined' && \n       typeof mk.garmin[(mk.garmin.length - 1)] !== 'undefined' &&\n       mk.garmin[(mk.garmin.length - 1)].target == here) {\n   mk.print('Reached destination: #<span class=\"violent\">' + here + '</span>, ' + mk.gmcp.name + '.')\n   mk.moving      = false\n   mk.garmin      = []\n   mk.destination = ''\n   mk.here = parseInt(mk.gmcp.num)\n   return }\n   if (here != mk.here) {\n    var t = mk.garmin || []\n    if (mk.moving) { // var u = t.slice(0, (mk.moveLimit))\n      var c = 0\n      var onPath = false\n      for (var k in t) {\n       c += 1\n       if (t[k].target == here) {\n         var o = mk.garmin.splice(0, c)\n         onPath = true\n         mk.spamCount = 0  // successful movement; reduce spam counter\n         if (false) { console.log('Removing steps.'); console.log(o) }\n         break\n       }\n      }\n      if (!onPath) {\n       console.log('Off path! ' + here)\n       mk.print('Moved off expected path. Stopping and reassessing. Heading towards ' + mk.destination + '.')\n       mk.send('ql')\n       mk.here = parseInt(mk.gmcp.num)\n       mk.goto(mk.destination)\n      }\n    }\n   }\n   mk.here = parseInt(mk.gmcp.num) }\n\n  mk.locate = function(room, name, area) {\n   // log('Searching for ' + name + ' @ ' + room + ', ' + area + '.')\n   var p = new Date().getTime()\n   var r = map.m.rooms\n   var a = map.m.areas\n   var list = []\n   var areaFlag = false\n   if (typeof area !== 'undefined') {\n    for (var k in a) { if (a[k] == area) { areaFlag = k; break } }\n   }\n   var keys = Object.keys(r)\n   for (var i=0; i<keys.length; i++) {\n    if (r[keys[i]].title == room) {\n      if (areaFlag) {\n       if (areaFlag == parseInt(r[keys[i]].area)) { list.push(r[keys[i]]) }\n      } else {\n       list.push(r[keys[i]]) }\n    }\n   }\n   var s = ''\n       s += 'Locating ' + name + ' ... <br >'\n   for (var i=0; i<list.length; i++) {\n    var t  = list[i]\n    var ar = t.area\n    var g  = mk.fmap.find(mk.here, t.id) // !important\n    list[i].path = g\n    for (var k in a) { if (k == ar) { ar = a[k] } }\n    s += ' (<span class=\"darkred\">' + mk.lpad(t.id,5,' ') + '</span>) ' + t.title + ', <i>' + ar + '</i> '\n    s += 'in <i>' + g.length + '</i> steps.<br >'}\n   if (list.length == 0) {\n    s += ' <span class=\"darkred\">Unable to locate ' + name + ' in known rooms.</span><br >'\n    s += ' Sorry! <span class=\"violent\">' + room + '</span>.<br >' + u + '<br >' }\n   s += '<br >'\n   s += 'Search took: ' + (new Date().getTime() - p) + ' ms.<br >'\n   mk.print(s)\n }\n\n mk.toggleDuanathar = function(value) {\n   if (typeof value !== 'undefined') {\n      if (value) { mk.useDuanathar = true } else { mk.useDuanathar = false }\n   } else {\n    if (mk.useDuanathar) {\n      mk.useDuanathar = false\n    } else {\n      mk.useDuanathar = true\n    }\n   }\n   if (mk.useDuanathar) { mk.print('Toggling <span class=\"darkred\">Duanathar</span> <span class=\"green\">ON</span>.') } else {\n    mk.print('Toggling <span class=\"darkred\">Duanathar</span> <span class=\"red\">OFF</span>.') }\n }\n mk.toggleVeil = function(value) {\n   if (typeof value !== 'undefined') {\n      if (value) { mk.useVeil = true } else { mk.useVeil = false }\n   } else {\n    if (mk.useVeil) {\n      mk.useVeil = false\n    } else {\n      mk.useVeil = true\n    }\n   }\n   if (mk.useVeil) { mk.print('Toggling <span class=\"darkred\">Veil</span> <span class=\"green\">ON</span>.') } else {\n    mk.print('Toggling <span class=\"darkred\">Veil</span> <span class=\"red\">OFF</span>.') }\n }\n mk.indoors = function() {\n   if (typeof gmcp !== 'undefined' &&\n       typeof gmcp.Room !== 'undefined' && \n       typeof gmcp.Room.Info !== 'undefined' &&\n       typeof gmcp.Room.Info.details !== 'undefined') {\n   for (var k in gmcp.Room.Info.details) {\n     if (gmcp.Room.Info.details[k] == 'indoors') { return true }\n   } }\n   return false\n }\n mk.isDragon = function() {\n   if (typeof gmcp !== 'undefined' &&\n       typeof gmcp.Char !== 'undefined' &&\n       typeof gmcp.Char.Status !== 'undefined' &&\n       typeof gmcp.Char.Status.class == 'string') {\n    var c = gmcp.Char.Status.class\n    if (c.match('Dragon')) {\n      return true\n    }\n   }\n   return false\n }"},{"type":"group","name":"Triggers","enabled":true,"id":21,"items":[{"type":"trigger","name":"-duanathar, city-orb","enabled":true,"id":29,"matching":"regexp","whole_words":true,"case_sensitive":true,"text":"^A shimmering orb covers the city, preventing you from rising to the skies\\.$","actions":[{"action":"script","script":"if (mk.moving) { mk.stop(); mk.print('Failed <span class=\"normal\"><i>duanathar</i></span>. Recommend using land route.') }"}]},{"type":"trigger","name":"farsee","enabled":true,"id":23,"matching":"regexp","whole_words":true,"case_sensitive":true,"text":"^You see that (\\w+) is located at (.*) in (.*)\\.$","actions":[{"action":"script","script":"mk.locate(args[2], args[1], args[3])"}]},{"type":"trigger","name":"mvt spam, dirt swim","enabled":true,"id":22,"matching":"regexp","whole_words":true,"case_sensitive":true,"text":"^You get down on your belly and begin trying to swim, but only succeed in rolling around in the dirt a bit\\.$","actions":[{"action":"script","script":"mk.spam()"}]},{"type":"trigger","name":"mvt spam, no exit","enabled":true,"id":19,"matching":"regexp","whole_words":true,"case_sensitive":true,"text":"^There is no exit in that direction\\.$","actions":[{"action":"script","script":"mk.spam()"}]},{"type":"trigger","name":"reassess, dirt swim","enabled":true,"id":24,"matching":"regexp","whole_words":true,"case_sensitive":true,"text":"^You get down on your belly and begin trying to swim, but only succeed in rolling around in the dirt a bit\\.$","actions":[{"action":"script","script":"if (mk.moving) {\n  mk.stop()\n  send_direct('ql') }"}]},{"type":"trigger","name":"reassess, stream","enabled":true,"id":25,"matching":"regexp","whole_words":true,"case_sensitive":true,"text":"^The swift river current quickly washes you downstream, to the (.*)\\.$","actions":[{"action":"script","script":"if (mk.moving) {\n  mk.stop()\n  send_direct('ql') }"}]}],"actions":[]},{"type":"alias","name":"-m, download map","enabled":true,"id":12,"matching":"regexp","whole_words":true,"case_sensitive":true,"prefix_suffix":true,"actions":[{"action":"script","script":"map.grab()"}],"text":"^\\-m$"},{"type":"alias","name":"af, area find","enabled":true,"id":11,"matching":"regexp","whole_words":true,"case_sensitive":true,"prefix_suffix":true,"actions":[{"action":"script","script":"map.areafind(args[1])"}],"text":"^af[ ]+(.+)$"},{"type":"alias","name":"rf, room find","enabled":true,"id":10,"matching":"regexp","whole_words":true,"case_sensitive":true,"prefix_suffix":true,"actions":[{"action":"script","script":"map.find(args[1])"}],"text":"^rf[ ]+(.+)$"},{"type":"alias","name":"rnum, room number","enabled":true,"id":13,"matching":"regexp","whole_words":true,"case_sensitive":true,"prefix_suffix":true,"actions":[{"action":"script","script":"mk.print('<span class=\"mute\">#<span class=\"normal\">' + mk.gmcp.num + '</span>')"}],"text":"^rnum$"},{"type":"alias","name":"mmake, AStar graphs","enabled":true,"id":20,"matching":"regexp","whole_words":true,"case_sensitive":true,"prefix_suffix":true,"actions":[{"action":"script","script":"mk.fashion()"}],"text":"^mmake$"},{"type":"alias","name":"mstop, stop mapper","enabled":true,"id":18,"matching":"regexp","whole_words":true,"case_sensitive":true,"prefix_suffix":true,"actions":[{"action":"script","script":"mk.stop()"}],"text":"^mstop$"},{"type":"alias","name":"pduan, toggle Duanathar","enabled":true,"id":26,"matching":"regexp","whole_words":true,"case_sensitive":true,"prefix_suffix":true,"actions":[{"action":"script","script":"mk.toggleDuanathar()"}],"text":"^pduan$"},{"type":"alias","name":"pg, path go ##","enabled":true,"id":15,"matching":"regexp","whole_words":true,"case_sensitive":true,"prefix_suffix":true,"actions":[{"action":"script","script":"mk.goto(args[1])"}],"text":"^pg[ ]+(\\d+)$"},{"type":"alias","name":"pn, path next to ##","enabled":true,"id":17,"matching":"regexp","whole_words":true,"case_sensitive":true,"prefix_suffix":true,"actions":[{"action":"script","script":"mk.goNext(args[1])"}],"text":"^pn[ ]+(\\d+)$"},{"type":"alias","name":"pveil, toggle Veil","enabled":true,"id":27,"matching":"regexp","whole_words":true,"case_sensitive":true,"prefix_suffix":true,"actions":[{"action":"script","script":"mk.toggleVeil()"}],"text":"^pveil$"},{"type":"alias","name":"prefer veil/duanathar","enabled":true,"id":28,"matching":"regexp","whole_words":true,"case_sensitive":true,"prefix_suffix":true,"actions":[{"action":"script","script":"mk.preferDV = args[1]\nmk.print('Preference set to <span class=\"red\">' + mk.preferDV + '</span>.')"}],"text":"^prefer[ ]+(veil|duanathar)$"}]}